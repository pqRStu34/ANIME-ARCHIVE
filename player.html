<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Anime Archive - Movie Player</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.6/dist/css/bootstrap.min.css" rel="stylesheet"
        crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.13.1/font/bootstrap-icons.min.css" />
    <style>
        .switcher-label i {
            color: #ff6685 !important;
        }

        .like-btn.active, .dislike-btn.active {
            font-weight: bold;
        }

        body {
            background: #14161a !important;
        }

        .card,
        .card-body {
            background: #16181d !important;
            border-color: #23252a !important;
        }

        .movie-info-card img {
            width: 110px;
            height: 160px;
            object-fit: cover;
            border-radius: 10px;
        }

        .movie-info-card .title {
            font-size: 1.5em;
            font-weight: 600;
            color: #fff;
        }

        .movie-info-card .meta {
            color: #00d1b2;
            font-size: 1.05em;
            margin-bottom: 0.5em;
        }

        .movie-info-card .desc {
            color: #ccc;
            font-size: 1em;
            margin-bottom: 1em;
        }

        .btn-info,
        .btn-outline-info,
        .btn-info.text-white {
            background-color: #6678ff !important;
            border-color: #6678ff !important;
            color: #fff !important;
        }

        .btn-outline-info {
            background: transparent !important;
            color: #6678ff !important;
        }

        .btn-outline-info:hover,
        .btn-outline-info:focus {
            background: #6678ff !important;
            color: #fff !important;
            border-color: #6678ff !important;
        }

        .movie-player {
            border-radius: 12px;
            width: 100%;
            background: #14161a;
            margin-bottom: 1.5em;
        }

        .switcher-row {
            display: flex;
            align-items: center;
            gap: 0.7em;
            margin-bottom: 1em;
        }

        .switcher-label {
            min-width: 60px;
            text-align: right;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            gap: 0.3em;
        }

        .switcher-btns {
            display: flex;
            align-items: center;
            gap: 0.5em;
        }
    </style>
</head>

<body>
    <div class="container mt-5">
        <div class="row justify-content-center">
            <div class="col-12 col-md-10 col-lg-8">
                <div class="card mb-0 border-0 bg-transparent">
                    <div class="card-body p-0 bg-transparent">
                        <video id="player" class="movie-player" controls crossorigin="anonymous" playsinline
                            width="100%" height="100%" style="border-radius: 12px; background: #14161a; width: 100%"
                            controlsList="nodownload" oncontextmenu="return false;"></video>
                    </div>
                </div>
                <!-- Language/Quality Switchers -->
                <div id="switcher-card" class="card mt-4 mb-4">
                    <div class="card-body">
                        <div class="mb-3 switcher-row">
                            <span class="switcher-label">
                                <i class="bi bi-translate"></i>
                            </span>
                            <div id="language-switcher" class="switcher-btns"></div>
                        </div>
                        <div class="mb-1 switcher-row">
                            <span class="switcher-label">
                                <i class="bi bi-film"></i>
                            </span>
                            <div id="quality-switcher" class="switcher-btns"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- Comments Section -->
        <div class="row justify-content-center mt-5">
            <div class="col-12 col-md-10 col-lg-8">
                <div class="card">
                    <div class="card-body">
                        <h3 class="card-title mb-4" style="color: #00d1b2; font-weight: 600;">Comments</h3>
                        <div class="mb-3">
                            <div class="d-flex align-items-start mb-3">
                                <div class="flex-grow-1">
                                    <textarea id="comment-input" class="form-control mb-2" placeholder="Add a comment..." rows="3" style="background: #1f2229; color: #fff; border: 1px solid #425277; border-radius: 8px;" maxlength="500"></textarea>
                                    <div class="d-flex justify-content-end">
                                        <button class="btn btn-sm me-2" id="cancel-comment" style="color: #ccc; background: none; border: none;">Cancel</button>
                                        <button class="btn btn-sm" id="post-comment" style="background: #00d1b2; color: #14161a; border: none; border-radius: 20px; padding: 6px 16px;">Comment</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div id="comments-container" style="max-height: 600px; overflow-y: auto;">
                            <!-- Comments will be appended here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script type="module">
        // Import Firebase modules
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js';
        import { getAnalytics } from 'https://www.gstatic.com/firebasejs/12.7.0/firebase-analytics.js';
        import { getFirestore, collection, addDoc, getDocs, doc, updateDoc, query, orderBy, where } from 'https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js';

        // Your web app's Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCDOsplwwR1I70Il5g1t7WbD4MHxxy29to",
            authDomain: "fire999999.firebaseapp.com",
            projectId: "fire999999",
            storageBucket: "fire999999.firebasestorage.app",
            messagingSenderId: "126475351718",
            appId: "1:126475351718:web:2bcfb7d4d3659230f0e667",
            measurementId: "G-5B9TQKZV58"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const analytics = getAnalytics(app);
        const db = getFirestore(app);

        // Custom Comments System with Firebase
        let currentMovieKey = '';
        let comments = [];
        let userInteractions = {}; // Track user interactions per comment: 'like', 'dislike', or null

        const commentsContainer = document.getElementById('comments-container');
        const commentInput = document.getElementById('comment-input');
        const postButton = document.getElementById('post-comment');
        const cancelButton = document.getElementById('cancel-comment');

        // Load comments for the movie
        async function loadComments() {
            currentMovieKey = getMovieKey();
            if (!currentMovieKey) return;
            // Load user interactions
            const storedInteractions = sessionStorage.getItem('interactions_' + currentMovieKey);
            userInteractions = storedInteractions ? JSON.parse(storedInteractions) : {};
            try {
                // Load all comments and filter in code to avoid index issues
                const querySnapshot = await getDocs(collection(db, 'comments'));
                comments = [];
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    if (data.movieKey === currentMovieKey) {
                        comments.push({ id: doc.id, ...data });
                    }
                });
                // Sort by timestamp desc
                comments.sort((a, b) => {
                    const aTime = a.timestamp.toMillis ? a.timestamp.toMillis() : a.timestamp;
                    const bTime = b.timestamp.toMillis ? b.timestamp.toMillis() : b.timestamp;
                    return bTime - aTime;
                });
                renderComments();
            } catch (error) {
                console.error('Error loading comments:', error);
            }
        }

        // Save comment to Firebase
        async function saveComment(comment) {
            try {
                const docRef = await addDoc(collection(db, 'comments'), comment);
                comment.id = docRef.id;
                comments.unshift(comment);
                renderComments();
            } catch (error) {
                console.error('Error saving comment:', error);
            }
        }

        // Update likes/dislikes
        async function updateInteraction(commentId, action) {
            try {
                const commentRef = doc(db, 'comments', commentId);
                const comment = comments.find(c => c.id === commentId);
                if (!comment) return;

                const current = userInteractions[commentId];
                let likesChange = 0;
                let dislikesChange = 0;

                if (current === action) {
                    // Toggle off
                    if (action === 'like') likesChange = -1;
                    else dislikesChange = -1;
                    userInteractions[commentId] = null;
                } else {
                    // Switch or set
                    if (current === 'like') likesChange = -1;
                    else if (current === 'dislike') dislikesChange = -1;
                    if (action === 'like') likesChange = 1;
                    else dislikesChange = 1;
                    userInteractions[commentId] = action;
                }

                comment.likes = (comment.likes || 0) + likesChange;
                comment.dislikes = (comment.dislikes || 0) + dislikesChange;

                await updateDoc(commentRef, {
                    likes: comment.likes,
                    dislikes: comment.dislikes
                });
                sessionStorage.setItem('interactions_' + currentMovieKey, JSON.stringify(userInteractions));
                renderComments();
            } catch (error) {
                console.error('Error updating interaction:', error);
            }
        }

        // Render comments (threaded)
        function renderComments() {
            commentsContainer.innerHTML = '';
            comments.forEach(comment => renderComment(comment, 0));
        }

        function renderComment(comment, depth) {
            const commentDiv = document.createElement('div');
            commentDiv.className = 'comment mb-3';
            commentDiv.style.marginLeft = depth * 40 + 'px';
            commentDiv.style.borderLeft = depth > 0 ? '2px solid #425277' : 'none';
            commentDiv.style.paddingLeft = depth > 0 ? '10px' : '0';

            const timeAgo = getTimeAgo(comment.timestamp);

            commentDiv.innerHTML = `
                <div class="d-flex align-items-start mb-2">
                    <div class="flex-grow-1">
                        <div class="d-flex align-items-center mb-1">
                            <span style="color: #00d1b2; font-weight: 500;">Anonymous</span>
                            <span style="color: #ccc; font-size: 0.9em; margin-left: 8px;">${timeAgo}</span>
                        </div>
                        <p style="color: #fff; margin: 0; line-height: 1.4;">${comment.text}</p>
                    </div>
                </div>
                <div class="d-flex align-items-center">
                    <button class="btn btn-sm me-3 like-btn ${userInteractions[comment.id] === 'like' ? 'active' : ''}" data-id="${comment.id}" style="color: ${userInteractions[comment.id] === 'like' ? '#00d1b2' : '#ccc'}; background: none; border: none; padding: 0;">
                        <i class="bi bi-hand-thumbs-up"></i> ${comment.likes || 0}
                    </button>
                    <button class="btn btn-sm me-3 dislike-btn ${userInteractions[comment.id] === 'dislike' ? 'active' : ''}" data-id="${comment.id}" style="color: ${userInteractions[comment.id] === 'dislike' ? '#ff6b6b' : '#ccc'}; background: none; border: none; padding: 0;">
                        <i class="bi bi-hand-thumbs-down"></i> ${comment.dislikes || 0}
                    </button>
                    ${depth < 2 ? `<button class="btn btn-sm reply-btn" data-id="${comment.id}" style="color: #ccc; background: none; border: none; padding: 0;">Reply</button>` : ''}
                </div>
                <div class="reply-form mt-2" style="display: none;">
                    <textarea class="form-control mb-2" placeholder="Reply..." rows="2" style="background: #1f2229; color: #fff; border: 1px solid #425277; border-radius: 8px;" maxlength="500"></textarea>
                    <div class="d-flex justify-content-end">
                        <button class="btn btn-sm me-2 cancel-reply" style="color: #ccc; background: none; border: none;">Cancel</button>
                        <button class="btn btn-sm post-reply" data-parent="${comment.id}" style="background: #00d1b2; color: #14161a; border: none; border-radius: 20px; padding: 4px 12px;">Reply</button>
                    </div>
                </div>
            `;

            commentsContainer.appendChild(commentDiv);

            // Render replies
            if (comment.replies) {
                comment.replies.forEach(reply => renderComment(reply, depth + 1));
            }
        }

        // Get time ago
        function getTimeAgo(timestamp) {
            const now = Date.now();
            const diff = now - timestamp.toMillis ? timestamp.toMillis() : timestamp;
            const minutes = Math.floor(diff / 60000);
            const hours = Math.floor(diff / 3600000);
            const days = Math.floor(diff / 86400000);
            if (minutes < 1) return 'just now';
            if (minutes < 60) return `${minutes}m`;
            if (hours < 24) return `${hours}h`;
            return `${days}d`;
        }

        // Post comment
        postButton.addEventListener('click', () => {
            const text = commentInput.value.trim();
            if (text) {
                const newComment = {
                    movieKey: currentMovieKey,
                    text: text,
                    timestamp: new Date(),
                    likes: 0,
                    dislikes: 0,
                    replies: []
                };
                saveComment(newComment);
                commentInput.value = '';
            }
        });

        // Cancel comment
        cancelButton.addEventListener('click', () => {
            commentInput.value = '';
        });

        // Handle like/dislike/reply
        commentsContainer.addEventListener('click', (e) => {
            const id = e.target.closest('button')?.dataset.id || e.target.closest('button')?.dataset.parent;
            if (!id) return;

            if (e.target.closest('.like-btn')) {
                updateInteraction(id, 'like');
            } else if (e.target.closest('.dislike-btn')) {
                updateInteraction(id, 'dislike');
            } else if (e.target.closest('.reply-btn')) {
                const replyForm = e.target.closest('.comment').querySelector('.reply-form');
                replyForm.style.display = replyForm.style.display === 'none' ? 'block' : 'none';
            } else if (e.target.closest('.cancel-reply')) {
                e.target.closest('.reply-form').style.display = 'none';
                e.target.closest('.reply-form').querySelector('textarea').value = '';
            } else if (e.target.closest('.post-reply')) {
                const parentId = e.target.dataset.parent;
                const text = e.target.closest('.reply-form').querySelector('textarea').value.trim();
                if (text) {
                    const reply = {
                        id: Date.now().toString(),
                        text: text,
                        timestamp: new Date(),
                        likes: 0,
                        dislikes: 0,
                        replies: []
                    };
                    // For simplicity, replies are not saved to Firebase separately; they could be stored as subcollections
                    const parent = comments.find(c => c.id === parentId);
                    if (parent) {
                        parent.replies = parent.replies || [];
                        parent.replies.push(reply);
                        // Update parent in Firebase
                        const parentRef = doc(db, 'comments', parentId);
                        updateDoc(parentRef, { replies: parent.replies });
                        renderComments();
                    }
                }
            }
        });

        // Load comments when movie loads
        window.addEventListener('load', loadComments);
    </script>
    <script>
        // Prevent long-press download on video (mobile and desktop)
        const preventVideoLongPress = () => {
            const video = document.getElementById('player');
            if (!video) return;
            // Prevent context menu
            video.addEventListener('contextmenu', e => e.preventDefault());
            // Prevent long-press on mobile
            let pressTimer = null;
            video.addEventListener('touchstart', function (e) {
                pressTimer = setTimeout(() => {
                    e.preventDefault();
                }, 400);
            }, { passive: false });
            video.addEventListener('touchend', function () {
                clearTimeout(pressTimer);
            });
        };
        window.addEventListener('DOMContentLoaded', preventVideoLongPress);
        // Get movie key from URL
        function getMovieKey() {
            const params = new URLSearchParams(window.location.search);
            return params.get("movie");
        }
        // Fetch movie JSON and render
        async function loadMovie() {
            try {
                const movieKey = getMovieKey();
                if (!movieKey) {
                    document.getElementById("movie-info").innerHTML = '<div class="p-3 text-danger">No movie selected.</div>';
                    document.getElementById("movie-info").style.display = '';
                    return;
                }
                const res = await fetch(movieKey + ".json");
                const movie = await res.json();
                setupPlayer(movie);
            } catch (e) {
                document.getElementById("movie-info").innerHTML = '<div class="p-3 text-danger">Failed to load movie.</div>';
                document.getElementById("movie-info").style.display = '';
            }
        }
        // Render movie info card

        // Setup player with best quality and populate switchers
        // Track current selection
        let currentSelection = { lang: null, quality: null };
        function setupPlayer(movie) {
            setupLanguageAndQualitySwitchers(movie);
            playMovie(movie);
        }

        // Populate language and quality switchers
        function setupLanguageAndQualitySwitchers(movie) {
            const sources = Array.isArray(movie.video) ? movie.video : [];
            const languageSwitcher = document.getElementById("language-switcher");
            const qualitySwitcher = document.getElementById("quality-switcher");
            languageSwitcher.innerHTML = '';
            qualitySwitcher.innerHTML = '';
            if (sources.length === 0) return;

            let allLangs = new Set();
            if (Array.isArray(sources)) {
                sources.forEach(src => {
                    const langMatch = src.src.match(/,([a-z]{3})$/);
                    if (langMatch) {
                        allLangs.add(langMatch[1]);
                    }
                });
            }
            allLangs = Array.from(allLangs);

            // Language buttons
            allLangs.forEach((lang) => {
                const btn = document.createElement("button");
                btn.className = "btn btn-outline-info btn-sm";
                btn.textContent = lang.toUpperCase();
                if (currentSelection.lang === lang) btn.classList.add('active');
                btn.onclick = () => {
                    currentSelection.lang = lang;
                    playMovie(movie);
                    setupLanguageAndQualitySwitchers(movie);
                };
                languageSwitcher.appendChild(btn);
            });

            // Quality buttons
            let qualitySources = sources;
            if (currentSelection.lang) {
                qualitySources = qualitySources.filter(s => s.src.endsWith(',' + currentSelection.lang));
            }
            let allQualities = new Set();
            qualitySources.forEach(src => {
                if (src.quality) allQualities.add(src.quality);
            });
            allQualities = Array.from(allQualities);
            allQualities.forEach((quality) => {
                const btn = document.createElement("button");
                btn.className = "btn btn-outline-info btn-sm";
                btn.textContent = quality;
                if (currentSelection.quality === quality) btn.classList.add('active');
                btn.onclick = () => {
                    currentSelection.quality = quality;
                    playMovie(movie);
                    setupLanguageAndQualitySwitchers(movie);
                };
                qualitySwitcher.appendChild(btn);
            });
        }

        // Play best quality or selected lang/quality
        function playMovie(movie) {
            const video = document.getElementById("player");
            if (!video) return;
            while (video.firstChild) video.removeChild(video.firstChild);
            const sources = Array.isArray(movie.video) ? movie.video : [];
            let source = null;
            if (sources.length > 0) {
                let filtered = sources;
                if (currentSelection.lang) {
                    filtered = filtered.filter(s => s.src.endsWith(',' + currentSelection.lang));
                }
                if (currentSelection.quality) {
                    filtered = filtered.filter(s => s.quality === currentSelection.quality);
                }
                // Prefer 4k, then 1080p, 720p, 480p, then first
                source = filtered.find(s => s.quality === "4k") ||
                    filtered.find(s => s.quality === "1080p") ||
                    filtered.find(s => s.quality === "720p") ||
                    filtered.find(s => s.quality === "480p") ||
                    filtered[0];
            }
            // Update currentSelection to reflect the actual source used
            if (source) {
                const langMatch = source.src.match(/,([a-z]{3})$/);
                currentSelection.lang = currentSelection.lang || (langMatch ? langMatch[1] : null);
                currentSelection.quality = currentSelection.quality || source.quality || null;
            }
            if (source) {
                video.src = source.src.replace(/,([a-z]{3})$/, '');
                video.type = source.type;
                // Load subtitles dynamically if lang in src
                const langMatch = source.src.match(/,([a-z]{3})$/);
                if (langMatch) {
                    const lang = langMatch[1];
                    const subtitleSrc = source.src.replace(/,([a-z]{3})$/, `_${lang}.vtt`);
                    const trackEl = document.createElement('track');
                    trackEl.kind = 'subtitles';
                    trackEl.label = lang.toUpperCase();
                    trackEl.srclang = lang;
                    trackEl.src = subtitleSrc;
                    trackEl.default = true;
                    video.appendChild(trackEl);
                }
                video.load();
                video.play();
            } else {
                video.removeAttribute("src");
                video.load();
            }
        }
        window.addEventListener("DOMContentLoaded", loadMovie);
    </script>
</body>

</html>